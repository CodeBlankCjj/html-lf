## HTML

1. 你是如何理解 HTML 语义化的？

> 语义化就是使用正确的标签，像段落就写p标签标题就写h1标签， 文章就写article标签，视频就用video标签 <br>
> HTML语义化是存在历史周期，
> 一开始是荒野阶段 是后台写HTML 使用HTML布局<br>
> 后来就是美工阶段 是美工写HTML 使用DIV+CSS布局 这个时候就有问题，不够语义化，分不清这个DIV跟那个DIV有什么区别<br>
> 再后来就是前端阶段 使用正确的标签来来描述正确的内容

2. meta viewport 是做什么用的，怎么写？

```html

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
```

宽度=设备的宽度, 初始缩放为1 最大缩放为1 最小缩放为1

3. 你用过哪些 HTML 5 标签？

- header
- main
- footer
- article
- section
- aside

4. H5 是什么？

> 在今天H5有广义和狭义两种 <br>
> 广义上H5指HTML5 第五代超文本标记语言
> 狭义就是值移动端页面

## CSS

1. 两种盒模型分别说一下。

> 盒模型分为两种<br>
> 一种是content-box -> 怪异盒模型
> 一种是border-box -> 标准盒模型
>
> 怪异盒模型的宽度是内容的宽度 + padding + border
> 标准盒模型的宽度就等于内容的宽度

2.如何垂直居中？

- table自带功能

```html

<table class="parent">
  <tr>
    <td class="child">
      一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字一串文字
    </td>
  </tr>
</table>
```

- table自带功能

3. flex 怎么用，常用属性有哪些？

- flex-direction 决定主轴的方向
- flex-wrap 决定是否换行
- justify-content 竖着的对齐方式
- align-items 横着的对其方式

4. BFC 是什么？

> 翻译成中文就是块级格式化上下文<br>
> BFC就是为元素提供一个独立的容器，在该容器里按照一定的规则进行布局排列，该容器内的元素不会影响外部的元素，同理，外部的元素也不会影响内部的元素<br>
> 浮动元素float不为none<br>
> 绝对定位 position为absolute 或fixed<br>
> overflow 不为 visible<br>
> display 为 inline-block 或 table 或 flow-root<br>

5. CSS 选择器优先级

- 越具体优先级越高
- 同样优先级写在后面的覆盖写在前面的
- !important 优先级最高，但是要少用

6. 清除浮动说一下

```css
.clearfix:after {
  content: '';
  display: block; /*或者 table*/
  clear: both;
}
.clearfix {
  zoom: 1; /* IE 兼容*/
}
```

## 原生JS

1. ES 6 语法知道哪些

> let const 箭头函数 Promise 展开操作符 默认参数 import export

2. Promise、Promise.all、Promise.race 分别怎么用

> Promise是一个对象 它代表了一个异步操作的最终完成或者失败

```js
function fn() {
  return new Promise((resolve, reject) => {
    成功时调用
    resolve(数据)
    失败时调用
    reject(错误)
  })
}
fn().then(success, fail).then(success2, fail2)
```

- Promise.all 用法

```js
Promise.all([promise1, promise2]).then(success1, fail1)
```

> promise1和promise2都成功才会调用success1

- Promise.race 用法

```js
Promise.race([promise1, promise2]).then(success1, fail1)
```

> 谁第一个成功或失败，就认为是race的成功或失败。

3.手写函数防抖和函数节流 节流

```js
function throttle(fn, delay) {
  let canUse = true
  return function () {
    if (canUse) {
      fn.apply(this, arguments)
      canUse = false
      setTimeout(() => canUse = true, delay)
    }
  }
}
```

防抖

```js
function debounce(fn, delay) {
  let timerId = null
  return function () {
    const context = this
    if (timerId) {
      window.clearTimeout(timerId)
    }
    timerId = setTimeout(() => {
      fn.apply(context, arguments)
      timerId = null
    }, delay)
  }
}
```

4,手写AJAX

```js
var request = new XMLHttpRequest()
request.open('GET', '/a/b/c?name=ff', true)
request.onreadystatechange = function () {
  if (request.readyState === 4 && request.status === 200) {
    console.log(request.responseText)
  }
  JSON.stringify()
}
request.send()
```

5.闭包/立即执行函数是什么？ -「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。

- 声明一个匿名函数 马上调用这个匿名函数

6.用正则实现 trim()

```js
function trim(string) {
  return string.replace(/^\s+|\s+$/g, '')
}
```

7.什么是 JSONP，什么是 CORS，什么是跨域？

- 跨域

> 跨域是浏览器的特性，就是浏览器从一个域向另一个域的服务器发出请求，来访问另一个域上的资源 但是,由于请求的文件可能会存在<br>
> 恶意攻击,浏览器就不允许直接访问另一个域上的资源,只能访问同一个域上的资源,这是同源策略,所谓的<br>同源策略就是协议,域名,端口号一致
> 不一致就是跨域了

- JSONP

> 在HTML中可以加载其它域下的js，比如我们经常引入其他域下线上cdn的jQuery<br>
> 假设我现在使用天气接口发送请求获取数据
> ```html
> <script src="api/weather/weather.php"></script>
> ```
> ,获取的数据然后作为JS来执行,但是这里有个问题,数据是JSON格式的数据可以这样试试
> ```html
> <script src="api/weather/weather.php?callback=showdata"></script>
> ```
> 之前返回的数据是 {"city": "hangzhou", "weather": "晴天"}
> 后面返回的数据就是 showData({"city": "hangzhou", "weather": "晴天"})

JSONP是通过script标签加载数据的方式去获取数据当作JS代码来时用   
提前在页面上声明一个函数,函数名通过接口传参的方式传给后台,后台解析到函数名后在原始数据上包裹这个函数名,发送给前端      
换句话说就是JSONP需要对应接口的后端配合才能实现

- CORS

> CORS是一个W3C标准,全称是跨域资源共享, 它允许浏览器向跨域浏览器发送出XMLHttpRequest请求,从而客服AJAX只能同源使用的限制

CORS优点是可以支持POST以及所有HTTP请求,前端要做的事较少,缺点就是不兼容老版本的浏览器 JSONP只能用于获取资源,类似GET请求

8. 不用 class 如何实现继承？用 class 又如何实现？

```js
function Animal(color) {
  this.color = color
}
Animal.prototype.move = function () {}
function Dog(color, name) {
  Animal.call(this, color)
  this.name = name
}
Dog.prototype.__proto__ = Animal.prototype
function temp() {}
temp.prototype = Animal.prototype
Dog.prototype = Animal.prototype

```

9. 数组去重 ```[...new Set(array)]```

## DOM

1. 事件委托

```js
ul.addEventListener('click', function (e) {
  if (e.target.tagName.toLowerCase() === 'li') {
    console.log('点击了')
  }
})
```

## HTTP

1. 状态码

- 100 continue
- 200 OK
- 204 no content
- 304 not modified
- 400 bad request
- 404 not found
- 401 需要身份验证
- 403 不能访问
- 408 请求时间过长
- 414 用户URL过长
- 422 不能处理的实体

2. HTTP缓存

- Etag MD5 会发送请求
- Expire 期日 BUG 用户可以修改本地时间
- Cache-Control 常用max-age=600 不会发送请求

3. get post
4. cookie 服务器发给浏览器字符串 浏览器 session 服务器与浏览器的一段会话 服务器

## vue

1. 钩子函数

- beforeCreate 创建之间
- created 创建之后
- beforeMount 挂在之前
- mounted 挂载之后
- beforeUpdate 更新之前
- updated 更新之后
- beforeDestroy 销毁之前
- destroyed 销毁之后

2. 组件通信

- 父子组件 $emit('xxx',date) $on('xxx', fun(){})
- 爷孙\兄弟 eventBus var eventBus = new Vue()    eventBus.$emit()  eventBUs.$on
- vuex

3. vuex vuex 专为vuejs应用程序开发是状态管理工具  
   五个核心概念
    - state          用来保存状态的
    - getters        可以认为是 store 的计算属性
    - mutations      需要修改state状态需要用到   同步执行
    - actions        可以进行异步执行
    - modules